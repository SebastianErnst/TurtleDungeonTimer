-- ============================================================================
-- Turtle Dungeon Timer - Group Synchronization
-- ============================================================================

TurtleDungeonTimer.SYNC_PREFIX = "TDT_SYNC"
TurtleDungeonTimer.SYNC_VERSION = "1.0"
TurtleDungeonTimer.playersWithAddon = {}  -- Track who has the addon
TurtleDungeonTimer.resetVotes = {}
TurtleDungeonTimer.resetInitiator = nil
TurtleDungeonTimer.resetVoteDialog = nil
TurtleDungeonTimer.currentRunId = nil

-- ============================================================================
-- UUID GENERATION
-- ============================================================================
function TurtleDungeonTimer:generateRunId()
    -- Simple UUID: timestamp + random number
    local timestamp = math.floor(GetTime() * 1000)
    local random = math.random(10000, 99999)
    return timestamp .. "-" .. random
end

-- ============================================================================
-- PLAYERS WITH ADDON TRACKING
-- ============================================================================
function TurtleDungeonTimer:checkForAddons()
    -- Clear list and request addon check
    self.playersWithAddon = {}
    
    -- Only check if in a group
    if GetNumRaidMembers() == 0 and GetNumPartyMembers() == 0 then
        return
    end
    
    self:sendSyncMessage("ADDON_CHECK")
end

function TurtleDungeonTimer:onAddonCheckResponse(sender)
    -- Add sender to addon users list
    self.playersWithAddon[sender] = true
end

function TurtleDungeonTimer:getAddonUserCount()
    local count = 0
    for _ in pairs(self.playersWithAddon) do
        count = count + 1
    end
    return count
end

-- ============================================================================
-- SYNC INITIALIZATION
-- ============================================================================
function TurtleDungeonTimer:initializeSync()
    -- Register sync event listener
    if not self.syncFrame then
        self.syncFrame = CreateFrame("Frame")
        self.syncFrame:RegisterEvent("CHAT_MSG_ADDON")
        self.syncFrame:RegisterEvent("PARTY_MEMBERS_CHANGED")
        self.syncFrame:RegisterEvent("RAID_ROSTER_UPDATE")
        
        self.syncFrame:SetScript("OnEvent", function()
            local instance = TurtleDungeonTimer:getInstance()
            
            if event == "CHAT_MSG_ADDON" then
                local prefix, message, channel, sender = arg1, arg2, arg3, arg4
                if prefix == TurtleDungeonTimer.SYNC_PREFIX then
                    instance:onSyncMessage(message, sender, channel)
                end
            elseif event == "PARTY_MEMBERS_CHANGED" or event == "RAID_ROSTER_UPDATE" then
                -- Group composition changed - recheck addons
                instance:checkForAddons()
            end
        end)
    end
    
    -- Initial addon check
    self:checkForAddons()
end

-- ============================================================================
-- SEND SYNC MESSAGES
-- ============================================================================
function TurtleDungeonTimer:sendSyncMessage(msgType, data)
    -- Don't send if not in a group
    if GetNumRaidMembers() == 0 and GetNumPartyMembers() == 0 then
        return
    end
    
    -- Build message: VERSION|TYPE|DATA
    -- Escape pipes in data to avoid issues with WoW chat system
    local message = self.SYNC_VERSION .. ";" .. msgType
    if data then
        -- Replace | with ~ to avoid WoW chat color code conflicts
        data = string.gsub(data, "|", "~")
    -- Check addon user count
    local addonUserCount = self:getAddonUserCount()
    
    if addonUserCount == 0 then
        -- No other addon users - reset directly
        self:performResetDirect()
        return
    end
    
    -- Other addon users exist - start voting
    self:startResetVote()
end

function TurtleDungeonTimer:startResetVote()
    -- Send reset request to group
    self:sendSyncMessage("RESET_REQUEST")
    
    -- Initialize vote tracking
    self.resetVotes = {}
    self.resetInitiator = UnitName("player")
    
    -- Initiator automatically votes YES
    self.resetVotes[UnitName("player")] = true
    
    -- Show message
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Turtle Dungeon Timer]|r Du hast eine Resetanfrage gestellt", 1, 1, 0)
end

function TurtleDungeonTimer:voteReset(vote)
    local playerName = UnitName("player")
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r voteReset() - Player: " .. playerName .. ", Vote: " .. tostring(vote), 1, 1, 1)
    
    -- Store own vote locally
    self.resetVotes[playerName] = vote
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r Vote lokal gespeichert", 1, 1, 1)
    
    -- Count and show own vote in chat
    local totalMembers = self:getGroupMemberCount()
    local yesVotes = 0
    
    for name, voteValue in pairs(self.resetVotes) do
        if voteValue then
            yesVotes = yesVotes + 1
        end
    end
    
    local voteStr = vote and "|cff00ff00Ja|r" or "|cffff0000Nein|r"
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Reset Vote]|r " .. playerName .. ": " .. voteStr .. " (" .. yesVotes .. "/" .. totalMembers .. " bestätigt)", 1, 1, 0)
    
    -- Send vote to group
    local voteSyncStr = vote and "YES" or "NO"
    self:sendSyncMessage("RESET_VOTE", playerName .. ";" .. voteSyncStr)
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r RESET_VOTE gesendet: " .. playerName .. ";" .. voteSyncStr, 1, 1, 1)
    
    -- Don't check votes immediately if we're the initiator voting for the first time
    -- Wait for others to vote (they will trigger checkResetVotes via onSyncResetVote)
    if self.resetInitiator ~= playerName then
        DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r Nicht Initiator - rufe checkResetVotes() auf", 1, 1, 1)
        self:checkResetVotes()
    end
end

function TurtleDungeonTimer:cancelResetVote()
    -- Send cancel message
    self:sendSyncMessage("RESET_CANCEL")
    
    -- Clear local vote data
    self.resetVotes = {}
    self.resetInitiator = nil
function TurtleDungeonTimer:voteReset(vote)
    local playerName = UnitName("player")
    
    -- Store vote locally
    self.resetVotes[playerName] = vote
    
    -- Send vote to group
    local voteSyncStr = vote and "YES" or "NO"
    self:sendSyncMessage("RESET_VOTE", playerName .. ";" .. voteSyncStr)
    
    -- Show message
    local voteStr = vote and "|cff00ff00Ja|r" or "|cffff0000Nein|r"
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Reset Vote]|r " .. playerName .. ": " .. voteStr, 1, 1, 0)
    
    -- Check if all votes are in
    self:checkResetVotes()
end

function TurtleDungeonTimer:cancelResetVote()
    -- Send cancel message
    self:sendSyncMessage("RESET_CANCEL")
    
    -- Clear local vote data
    self.resetVotes = {}
    self.resetInitiator = nil
    
    -- Hide dialog if open
    if self.resetVoteDialog then
        self.resetVoteDialog:Hide()
    end
end

function TurtleDungeonTimer:syncBossKill(bossName, killTime, splitTime)
    -- Send: BOSS;bossName;killTime;splitTime;runId
    local data = bossName .. ";" .. string.format("%.2f", killTime) .. ";" .. string.format("%.2f", splitTime)
    if self.currentRunId then
        data = data .. ";" .. self.currentRunId
    end
    self:sendSyncMessage("BOSS", data)
end

function TurtleDungeonTimer:syncDeath()
    -- Send: DEATH;runId
    if self.currentRunId then
        self:sendSyncMessage("DEATH", self.currentRunId)
    else
        self:sendSyncMessage("DEATH")
    end
end

-- ============================================================================
-- RECEIVE SYNC MESSAGES
-- ============================================================================
function TurtleDungeonTimer:onSyncMessage(message, sender, channel)
    
    -- Restore pipes in data
    if data then
        data = string.gsub(data, "~", ";")
    end
    
    -- Handle different message types
    if msgType == "ADDON_CHECK" then
        -- Respond that we have the addon
        self:sendSyncMessage("ADDON_RESPONSE")
    elseif msgType == "ADDON_RESPONSE" then
        self:onAddonCheckResponse(sender)
    else    return
    end
    
    -- If we're not running, sync start and store the run ID
    if not self.isRunning then
        -- Store the run ID from the sync message
        if runId and runId ~= "" then
            self.currentRunId = runId
        end
        -- Select same dungeon if not already selected
        if self.selectedDungeon ~= dungeonName or self.selectedVariant ~= variantName then
            self:selectDungeon(dungeonName)
            self:selectVariant(variantName)
        end
        
        -- Start timer with synced timestamp
        local serverTime = tonumber(timestamp)
        if serverTime then
            self.isRunning = true
            self.startTime = serverTime
            self.killTimes = {}
            self.deathCount = 0
            
            -- Collect player info
            self.playerName = UnitName("player") or "Unknown"
            self.guildName = GetGuildInfo("player") or "No Guild"
            self.groupClasses = self:collectGroupClasses()
            
            -- Reset UI
            self:resetUI()
            
            -- Minimize the frame
            if not self.minimized then
                self:toggleMinimized()
            end
            
            DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Turtle Dungeon Timer]|r Timer synchronisiert mit " .. sender, 1, 1, 0)
        end
    end
end

function TurtleDungeonTimer:onSyncStop(sender)
    -- Don't auto-stop, let each player control their own stop
    -- Just show a message
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Turtle Dungeon Timer]|r " .. sender .. " hat den Timer gestoppt", 1, 1, 0)
end

function TurtleDungeonTimer:onSyncResetRequest(sender)
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r onSyncResetRequest von: " .. sender, 1, 1, 1)
    
    -- Store initiator
    self.resetInitiator = sender
    self.resetVotes = {}
    
    -- Only initialize resetAddonUsers if not already set
    if not self.resetAddonUsers then
        self.resetAddonUsers = {}
    end
    
    -- Add sender (initiator) to addon users
    self.resetAddonUsers[sender] = true
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r Initiator " .. sender .. " zu resetAddonUsers hinzugefügt", 1, 1, 1)
    -- Store initiator
    self.resetInitiator = sender
    self.resetVotes = {}
    
    -- Show message
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Turtle Dungeon Timer]|r " .. sender .. " hat Resetanfrage gestellt", 1, 1, 0)
    
    -- Show vote dialog (only if not the initiator)
    if sender ~= UnitName("player") then
        self:showResetVoteDialog(sender
    -- Don't process own vote message (already shown in voteReset)
    if playerName == UnitName("player") then
        DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r Eigene Vote-Message ignoriert", 1, 1, 1)
        return
    end
    
    -- Mark that we received a vote from someone else
    self.receivedAnyVoteResponse = true
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r Vote-Response von anderem Spieler erhalten!", 1, 1, 1)
    -- Parse: playerName;vote
    local _, _, playerName, vote = string.find(data, "([^;]+);([^;]+)")
    
    if not playerName or not vote then
        return
    end
    
    -- Don't process own vote message
    if playerName == UnitName("player") then
        return
    end
    
    -- Store vote
    self.resetVotes[playerName] = (vote == "YES")
    
    -- Show vote result
    local voteStr = vote == "YES" and "|cff00ff00Ja|r" or "|cffff0000Nein|r"
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Reset Vote]|r " .. playerName .. ": " .. voteStr, 1, 1, 0)
    
    -- Check if all votes are in0[Turtle Dungeon Timer]|r Reset-Abstimmung abgebrochen", 1, 1, 0)
end

function TurtleDungeonTimer:onSyncResetExecute(sender)
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r onSyncResetExecute von: " .. sender, 1, 1, 1)
    
    -- Execute reset for everyone
    self:performResetSilent()
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r performResetSilent() ausgeführt", 1, 1, 1)
    
    -- Clear vote data
    self.resetVotes = {}
    self.resetAddonUsers = {}
    self.resetInitiator = nil
    self.resetAddonCheckComplete = false
    self.receivedAnyVoteResponse = false
    
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Turtle Dungeon Timer]|r Timer wurde zurückgesetzt (Gruppenbeschluss)", 1, 1, 0)
end

function TurtleDungeonTimer:onSyncBossKill(data, sender)
    if not self.isRunning then return end
    
    -- Clear vote data
    self.resetVotes = {}
    self.resetInitiator = nil
    
    -- Old parsing for backward compatibility
    local _, _, bossName, killTimeStr, splitTimeStr = string.find(data, "([^;]+);([^;]+);([^;]+)")
    
    if not bossName or not killTimeStr or not splitTimeStr then
        return
    end
    
    local killTime = tonumber(killTimeStr)
    local splitTime = tonumber(splitTimeStr)
    
    if not killTime or not splitTime then
        return
    end
    
    -- Execute reset for everyone
    self:performResetSilent()
    
    -- Clear vote data
    self.resetVotes = {}
    self.resetInitiator = nil
    
    -- Check if we already have this kill
    for i = 1, table.getn(self.killTimes) do
        if self.killTimes[i].index == bossIndex then
            -- Already recorded
            return
        end
    end
    
    -- Add kill to our list
    table.insert(self.killTimes, {
        bossName = bossName,
        time = killTime,
        index = bossIndex,
        splitTime = splitTime
    })
    
    -- Update UI
    self:updateBossRow(bossIndex, killTime, splitTime)
    
    -- Check if all bosses are dead
    local requiredBosses = self:getRequiredBossCount()
    local requiredKills = self:getRequiredBossKills()
    if requiredKills >= requiredBosses then
        self:onAllBossesDefeated()
    end
end

function TurtleDungeonTimer:onSyncDeath(data, sender)
    if not self.isRunning then return end
    
    -- Parse run ID if present
    local runId = data
    if runId and runId ~= "" and self.currentRunId and runId ~= self.currentRunId then
        -- Different run, ignore this message
        return
    end
    
    -- Increment death counter for the group
    self.deathCount = (self.deathCount or 0) + 1
    
    -- Update death counter in UI
    if self.frame and self.frame.deathText then
        self.frame.deathText:SetText("Deaths: " .. self.deathCount)
    end
    
    -- Show message in chat
    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[Turtle Dungeon Timer]|r " .. sender .. " ist gestorben (Deaths: " .. self.deathCount .. ")", 1, 0.5, 0)
end

-- ============================================================================
-- HELPER: Get group channel and member count
-- ============================================================================
function TurtleDungeonTimer:getGroupMemberCount()
    if GetNumRaidMembers() > 0 then
        return GetNumRaidMembers()
    elseif GetNumPartyMembers() > 0 then
        return GetNumPartyMembers() + 1  -- +1 for player
    end
    return 1  -- Solo
end

function TurtleDungeonTimer:getGroupChannel()
    if GetNumRaidMembers() > 0 then
        return "RAID"
    elseif GetNumPartyMembers() > 0 then
        return "PARTY"
    end
    return nil
end

-- ============================================================================
-- RESET VOTE SYSTEM
-- ============================================================================
function TurtleDungeonTimer:checkResetVotes()
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r checkResetVotes() aufgerufen", 1, 1, 1)
    
    if not self.resetVotes or not self.resetAddonUsers then
        DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r resetVotes oder resetAddonUsers fehlt", 1, 1, 1)
        return
    end
    
    -- Only check votes from addon users (not all group members)
    local totalAddonUsers = 0
    local votedMembers = 0
    local yesVotes = 0
    
    for name, _ in pairs(self.resetAddonUsers) do
        totalAddonUsers = totalAddonUsers + 1
        if self.resetVotes[name] ~= nil then
            votedMembers = votedMembers + 1
            if self.resetVotes[name] == true then
                yesVotes = yesVotes + 1
            end
        end
    end
    
    DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[DEBUG]|r Addon-Nutzer: " .. totalAddonUsers .. ", Voted: " .. votedMembers .. ", JA: " .. yesVotes, 1, 1, 1)
    
    -- Check if all addon users voted
    local allVoted = (votedMembers >= totalAddonUsers)
    
    if not self.resetVotes then
        return
    end
    
    -- Count votes from addon users
    local totalAddonUsers = self:getAddonUserCount() + 1  -- +1 for self
    local votedMembers = 0
    local yesVotes = 0
    
    for name, voteValue in pairs(self.resetVotes) do
        votedMembers = votedMembers + 1
        if voteValue then
            yesVotes = yesVotes + 1
        end
    end
    
    -- Check if all addon users voted
    local allVoted = (votedMembers >= totalAddonUsers)
    
    if allVoted then
        -- Check if everyone voted YES
        if yesVotes == totalAddonUsers then
            -- Everyone voted YES - execute reset
            self:sendSyncMessage("RESET_EXECUTE")
            self.resetVotes = {}
            self.resetInitiator = nil
        else
            -- At least one NO vote - cancel reset
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[Turtle Dungeon Timer]|r Reset wurde abgelehnt", 1, 0, 0)
            self:sendSyncMessage("RESET_CANCEL")
            self.resetVotes = {}
            self.resetInitiator = nil
        end
    else
        -- Show progress
    -- Title
    local title = dialog:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
    title:SetPoint("TOP", dialog, "TOP", 0, -15)
    title:SetText("Timer Reset?")
    title:SetTextColor(1, 0.82, 0)
    
    -- Message line 1
    local message1 = dialog:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    message1:SetPoint("TOP", title, "BOTTOM", 0, -10)
    message1:SetWidth(260)
    message1:SetText(initiator .. " möchte den Timer zurücksetzen.")
    message1:SetJustifyH("CENTER")
    
    -- Message line 2
    local message2 = dialog:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    message2:SetPoint("TOP", message1, "BOTTOM", 0, -10)
    message2:SetWidth(260)
    message2:SetText("Stimmen Sie zu?")
    message2:SetJustifyH("CENTER")
    
    -- Yes Button
    local yesButton = CreateFrame("Button", nil, dialog, "GameMenuButtonTemplate")
    yesButton:SetWidth(100)
    yesButton:SetHeight(30)
    yesButton:SetPoint("BOTTOMLEFT", dialog, "BOTTOM", -105, 15)
    yesButton:SetText("Ja")
    yesButton:SetScript("OnClick", function()
        TurtleDungeonTimer:getInstance():voteReset(true)
        dialog:Hide()
    end)
    
    -- No Button
    local noButton = CreateFrame("Button", nil, dialog, "GameMenuButtonTemplate")
    noButton:SetWidth(100)
    noButton:SetHeight(30)
    noButton:SetPoint("BOTTOMRIGHT", dialog, "BOTTOM", 105, 15)
    noButton:SetText("Nein")
    noButton:SetScript("OnClick", function()
        TurtleDungeonTimer:getInstance():voteReset(false)
        dialog:Hide()
    end)
    
    -- Auto-close after 30 seconds (vote NO)
    dialog.timeout = 30
    dialog:SetScript("OnUpdate", function()
        dialog.timeout = dialog.timeout - arg1
        if dialog.timeout <= 0 then
            TurtleDungeonTimer:getInstance():voteReset(false)
            dialog:Hide()
        end
    end)
    
    dialog:Show()
end
